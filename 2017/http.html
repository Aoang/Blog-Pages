<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="//946771200.xyz"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="dns-prefetch" href="//www.googletagmanager.com"><link rel="dns-prefetch" href="//www.google-analytics.com"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,maximum-scale=5,viewport-fit=cover"><meta name="renderer" content="webkit"><title>简述 HTTP | Aoang&#39;s Blog</title><link rel="icon" type="image&#x2F;ico" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/apple-touch-icon.png"><link rel="icon" typt="image&#x2F;png" sizes="192x192" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/android-chrome-192x192.png"><link rel="icon" typt="image&#x2F;png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/favicon-32x32.png"><link rel="icon" typt="image&#x2F;png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/favicon-16x16.png"><link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/safari-pinned-tab.svg" color=""><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/spectre.css@latest"><style>body{background-color:#f8f9fa}a,a:visited{color:#0070ff}a:active,a:focus,a:hover{color:#0070ff;opacity:.75}#post-content a,#post-content a:focus,#post-content a:hover,#post-content a:visited{color:#005eb9;opacity:1}.post-entry .card-body a{color:#0070ff}.avatar{background:#444}.navbar-link,.navbar-link:visited,.timeline .timeline-item .timeline-icon.icon-lg{color:#0070ff}.navbar-link:hover{color:#0070ff;opacity:.8}#disqus-loadmore-button,#disqus-switch-to-direct,#disqus_click_btn,#search-input .btn{background:#727e96;border-color:#727e96;color:#fff}#post-toc a.post-toc-link,#post-toc a.post-toc-link:visited,.share-menu.menu .menu-item>a{color:#727e96}.share-menu.menu .menu-item>a:focus,.share-menu.menu .menu-item>a:hover,.share-menu.menu .menu-item>a:visited{color:#50596c;background:#f8f9fa;opacity:.85}</style><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/css/highlight/github.min.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="/css/highlight/github.min.css"></noscript><script>!function(n){"use strict";n.loadCSS||(n.loadCSS=function(){});var o=loadCSS.relpreload={};if(o.support=function(){var e;try{e=n.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),o.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},o.poly=function(){if(!o.support())for(var t=n.document.getElementsByTagName("link"),e=0;e<t.length;e++){var a=t[e];"preload"!==a.rel||"style"!==a.getAttribute("as")||a.getAttribute("data-loadcss")||(a.setAttribute("data-loadcss",!0),o.bindMediaToggle(a))}},!o.support()){o.poly();var t=n.setInterval(o.poly,500);n.addEventListener?n.addEventListener("load",function(){o.poly(),n.clearInterval(t)}):n.attachEvent&&n.attachEvent("onload",function(){o.poly(),n.clearInterval(t)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:n.loadCSS=loadCSS}("undefined"!=typeof global?global:this)</script><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="Aoang's Blog"><meta name="msapplication-starturl" content="https://01.946771200.xyz"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Aoang's Blog"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link rel="manifest" href="/manifest.json"><link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="Aoang's Blog"><meta property="og:title" content="简述 HTTP | Aoang&#39;s Blog"><meta property="og:site_name" content="Aoang&#39;s Blog"><meta property="og:type" content="article"><meta property="og:url" content="https:&#x2F;&#x2F;01.946771200.xyz&#x2F;2017&#x2F;http.html"><meta property="og:locale" content="zh-CN"><meta name="description" content="简述 HTTP - Aoang - Aoang&#39;s Blog"><meta name="keywords" content="Aoang, Aoangc, Blog, 博客, 网络, 安全"><meta property="og:image" content="https:&#x2F;&#x2F;01.946771200.xyz&#x2F;img&#x2F;http2&#x2F;http-http2-1.svg"><meta property="og:image" content="https:&#x2F;&#x2F;01.946771200.xyz&#x2F;img&#x2F;http2&#x2F;http-http2-2.svg"><meta property="og:image" content="https:&#x2F;&#x2F;01.946771200.xyz&#x2F;img&#x2F;http2&#x2F;http-http2-3.png"><meta property="article:published_time" content="2017-04-04T21:05:01.000Z"><meta property="article:modified_time" content="2021-06-11T08:02:37.187Z"><meta property="og:updated_time" content="2021-06-11T08:02:37.187Z"><meta property="article:author" content="Aoang"><meta property="article:tag" content="Aoang, Aoangc, Blog, 博客, 网络, 安全"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://01.946771200.xyz/2017/http.html"><meta name="generator" content="Hexo 4.0.0"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-130715850-2"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-130715850-2")</script><script type="application/ld+json">{
    "@context": "http://schema.org",
    "url": "https://01.946771200.xyz/2017/http.html",
    "@type": "BlogPosting",
    "logo": "https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/android-chrome-192x192.png",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://01.946771200.xyz/2017/http.html"
    },
    "headline": "简述 HTTP | Aoang&#39;s Blog",
    
    "image": {
        "@type": "ImageObject",
        "url": "https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/android-chrome-192x192.png"
    },
    
    "datePublished": "2017-04-04T21:05:01.000Z",
    "dateModified": "2021-06-11T08:02:37.187Z",
    "author": {
        "@type": "Person",
        "name": "Aoang",
        "image": {
            "@type": "ImageObject",
            "url": "https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/img.png"
        },
        "description": "岁月在电波中流淌，人生在音乐中升华"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Aoang&#39;s Blog",
        "logo": {
            "@type": "ImageObject",
            "url": "https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/android-chrome-192x192.png"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "https://01.946771200.xyz/search.html?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "Aoang, Aoangc, Blog, 博客, 网络, 安全",
    "description": "简述 HTTP - Aoang - Aoang&#39;s Blog"
}</script><link rel="alternate" href="/atom.xml" title="Aoang's Blog" type="application/atom+xml"></head><body><header><h1 class="header-title text-center"><a href="/">Aoang&#39;s Blog</a></h1><p class="text-center header-slogan">岁月在电波中流淌，人生在音乐中升华</p><nav class="navbar-section text-center"><a href="/" class="navbar-link">首页</a> <a href="/archives/" class="navbar-link">归档</a> <a href="/search.html" class="navbar-link">搜索</a> <a href="/project.html" class="navbar-link">项目</a> <a href="/wiki/" class="navbar-link">文档</a> <a href="/links.html" class="navbar-link">友链</a> <a href="/about.html" class="navbar-link">关于</a></nav></header><div class="post-container"><div id="post-card" class="card"><div class="card-item-container"><div class="card-inner-cell"><div class="card-header"><h1 class="card-title h3 mb-2">简述 HTTP</h1><div class="post-header-info"><p class="post-header-info-left text-gray"><img class="author-thumb lazyload" data-src="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/img.png" src="/img/suka-lazyload.gif" alt="Aoang's Avatar"> <span>2017-04-05</span></p><div class="post-header-info-right"></div></div></div><div class="card-body"><div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#什么是-HTTP？"><span class="post-toc-number">1.</span> <span class="post-toc-text">什么是 HTTP？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTP-0-9-1991"><span class="post-toc-number">2.</span> <span class="post-toc-text">HTTP/0.9 - 1991</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTP-1-0-1996"><span class="post-toc-number">3.</span> <span class="post-toc-text">HTTP/1.0 - 1996</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTP-1-1-1999"><span class="post-toc-number">4.</span> <span class="post-toc-text">HTTP/1.1 - 1999</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SPDY-2009"><span class="post-toc-number">5.</span> <span class="post-toc-text">SPDY - 2009</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTP-2-2015"><span class="post-toc-number">6.</span> <span class="post-toc-text">HTTP/2 - 2015</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-二进制协议"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">1. 二进制协议</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#帧和流"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">帧和流</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-多路复用"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">2. 多路复用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-HPACK-头部压缩"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">3. HPACK 头部压缩</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-服务器推送"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">4. 服务器推送</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-请求优先级"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">5. 请求优先级</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-安全"><span class="post-toc-number">6.6.</span> <span class="post-toc-text">6. 安全</span></a></li></ol></li></ol></div><article id="post-content"><h2 id="什么是-HTTP？"><a href="#什么是-HTTP？" class="headerlink" title="什么是 HTTP？"></a>什么是 HTTP？</h2><p>首先，HTTP 是什么？ HTTP 是基于 <code>TCP/IP</code> 的应用层通信协议，用于标准化客户端和服务器之间的通信方式。 它定义了如何通过互联网请求和传输内容。 应用层协议，我的意思是它只是一个抽象层，它规范了主机（客户端和服务器）如何通信，并且它本身依赖于 <code>TCP/IP</code> 来获取客户端和服务器之间的请求和响应。 默认情况下使用 TCP 端口<code>80</code>，HTTPS 使用 <code>443</code>。</p><h2 id="HTTP-0-9-1991"><a href="#HTTP-0-9-1991" class="headerlink" title="HTTP/0.9 - 1991"></a>HTTP/0.9 - 1991</h2><p>第一个 HTTP 版本是 <code>HTTP/0.9</code> 在1991年提出的。它是有史以来最简单的协议; 只有一个叫做 <code>GET</code> 的方法 。如果客户不得不访问服务器上的某个网页，它会发出如下的简单请求</p><p><code>GET /index.html</code></p><p>服务器的响应看起来如下所示</p><p><code>(response body)</code><br><code>(connection closed)</code></p><p>也就是说，服务器会收到请求，并回复 <code>HTML</code>，一旦内容被传输，连接将被关闭。它有着以下限制</p><ul><li>没有头信息（HTTP header）</li><li>只有 <code>GET</code> 方法</li><li>只能返回 <code>HTML</code></li></ul><p>正如你所看到的，该协议实际上只不过是未来的垫脚石。</p><h2 id="HTTP-1-0-1996"><a href="#HTTP-1-0-1996" class="headerlink" title="HTTP/1.0 - 1996"></a>HTTP/1.0 - 1996</h2><p>在 1996 年，下一版本的 HTTP 即 <code>HTTP/1.0</code> 得到了极大改进，超过了原始版本。</p><p>与 <code>HTTP/0.9</code> 仅针对 HTML 响应设计的不同，<code>HTTP/1.0</code> 现在可以处理其他响应格式，即图像，视频文件，纯文本或任何其他内容类型。它添加了更多的方法（即 POST 和 HEAD），请求/响应格式发生了变化，HTTP 头添加到请求和响应中，添加了状态码以识别响应，引入了字符集支持，多部分类型，授权，缓存，内容编码等内容。</p><p>以下是示例 <code>HTTP/1.0</code> 请求和响应的样子：</p><p><code>GET / HTTP/1.0</code><br><code>Host: aoang.github.io</code><br><code>User-Agent: Mozilla/5.0 (X11; Linux x86_64)</code><br><code>Accept: */*</code></p><p>正如你所看到的，除了请求之外，客户端还发送了它的个人信息，所需的响应类型等。在 <code>HTTP/0.9</code> 客户端中永远不会发送这样的信息。</p><p>以上对请求的响应示例可能如下所示</p><p><code>HTTP/1.0 200 OK</code><br><code>Content-Type: text/plain</code><br><code>Content-Length: 123456</code><br><code>Expires: Thu, 10 Dec 1999 00:00:00 GMT</code><br><code>Last-Modified: Thu, 10 Dec 1998 00:00:00 GMT</code><br><code>Server: Apache</code></p><p><code>(response body)</code><br><code>(connection closed)</code></p><p>在响应的一开始就有 <code>HTTP/1.0</code> （HTTP 后跟版本号），然后是 200 状态码。</p><p>在这个更新的版本中，请求和响应标头仍然保持 <code>ASCII</code> 编码状态，但响应主体可以是任何类型的图片，视频，HTML，纯文本或任何其他内容类型。所以，现在服务器可以发送任何内容类型给客户端; 在引入之后不久，<code>HTTP</code> 中的“超文本”一词就名不副实了。HMTP 或者超媒体传输协议可能会更有意义，但是我想，这估计难以改变了。</p><p><code>HTTP/1.0</code> 其中有一个主要缺点，无法为每个连接提供多个请求。也就是说，无论何时客户端需要从服务器获取一些东西，它将不得不打开一个新的 TCP 连接，并且在这之后单个请求已经完成，连接被关闭。对于任何下一个要求，它必须在一个新的连接上。如果你还不明白？那么，让我们假设你访问了一个包含十张图片，五个 CSS 和五个 JavaScript 文件的网页，这些文件是当对该网页的请求发生时需要获取的。由于服务器在请求完成后立即关闭连接，因此会有一系列的单独的连接去获取这些文件，每个文件将在其单独的连接上逐一提供。这种大量的 TCP 连接会导致严重的性能下降，因为新连接会由于三次握手和慢启动而导致显着的性能损失。</p><p><strong>三方握手</strong></p><p>简单来说，三次握手的形式是，所有 <code>TCP</code> 连接都以三次握手开始，客户端和服务器在开始传输数据之前发送一系列数据包。</p><ul><li><code>SYN</code> - 客户端发送 <code>SYN</code> 包 (SYN = x) 到服务器，并进入 <code>SYN_SEND</code> 状态，等待服务器确认</li><li><code>SYN ACK</code> - 服务器收到 <code>SYN</code> 包，必须确认客户的 <code>SYN</code> （ACK = x + 1），同时自己也发送一个 <code>SYN</code> 包 (SYN = y)，即 <code>SYN</code> 和 <code>ACK</code> 包，此时服务器进入 <code>SYN_RECV</code> 状态；</li><li><code>ACK</code> - 客户端收到服务器的 <code>SYN</code> 和 <code>ACK</code> 包，向服务器发送确认包 <code>ACK</code> (ACK = y + 1)，此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code> 状态，完成三次握手。</li></ul><p>一旦三次握手完成，客户端和服务器之间的数据传输就可以开始了。应该注意的是，客户端可能会在发送最后一个 <code>ACK</code> 数据包后立即开始发送数据，但服务器必须接受到此 <code>ACK</code> 数据包才能进行请求。</p><p><img src="/img/http2/http-http2-1.svg" alt=""></p><p>然而，一些 HTTP/1.0 的实现试图通过引入一个新的头信息 <code>Connection: keep-alive</code> 来解决这个问题。这个头信息是为了告诉服务器保持连接状态。但并没有得到广泛支持，问题依然存在。</p><p><code>HTTP</code> 除了是无连接的协议外，也是一种无状态协议，即服务器不维护有关客户端的信息。例如：服务器不维护关于客户端的信息，因此，在与任何旧的请求没有任何关联的情况下，服务器为了能完成请求，需要每一个请求都带有服务器所需的信息。所以，客户端除了要进行大量的连接，还必须发送一些冗余的数据，导致了需要使用更多的带宽。</p><h2 id="HTTP-1-1-1999"><a href="#HTTP-1-1-1999" class="headerlink" title="HTTP/1.1 - 1999"></a>HTTP/1.1 - 1999</h2><p>仅 3 年，下一版本 <code>HTTP/1.1</code> 在 1999 年发布，这个版本对之前做了很多改进。主要包括</p><ul><li><p><strong>新的 HTTP 方法</strong> <code>PUT</code>, <code>PATCH</code>, <code>OPTIONS</code>, <code>DELETE</code></p></li><li><p><strong>主机名标识</strong> 在 <code>HTTP/1.0</code> 中 <code>Host</code> 不是必须的，但是在 <code>HTTP/1.1</code> 中它是必需的。</p></li><li><p><strong>持久连接</strong> 如上所述，<code>HTTP/1.0</code> 每个连接只有一个请求，且一旦请求完成就会关闭连接，从而导致性能、延迟问题。 <code>HTTP/1.1</code> 引入了持久连接，即 <strong>默认情况下连接不会自动关闭</strong>，并保持打开状态，允许多个连续请求。要关闭连接，将 <code>Connection: close</code> 加入到请求的头信息中。客户端通常在最后一个请求中发送该头以安全关闭连接。</p></li><li><p><strong>管线化</strong> 它还引入了对管线化的支持，客户端可以向服务器发送多个请求，而无需等待来自同一连接上的服务器的响应。</p></li></ul><blockquote><p>应该注意使用持久连接或管线化时，<code>Content-Length</code> 头部必须在可用响应中，因为这会让客户端知道传输何时完成，并且它可以发送下一个请求（以正常的顺序方式发送请求）或者开始等待下一个响应（启用管线化时）。</p></blockquote><blockquote><p>但这种方法仍然存在问题。如果数据是动态的，并且服务器无法找到之前的 <code>Content-Length</code> ，那该怎么办？那么在那种情况下，你就无法使用持久连接你，不是么？为了解决这个问题，<code>HTTP/1.1</code> 引入了分块传输。在这种情况下，服务器可能会忽略 <code>Content-Length</code> 以支持分块编码。如果它们都不可用，则在请求结束时关闭连接。</p></blockquote><ul><li><p><strong>分块传输</strong> 在动态内容的情况下，当服务器无法找到 <code>Content-Length</code> 的话，它可以开始发送片段内容并在发送时给每个块添加 <code>Content-Length</code>。当所有的数据块都被发送完毕，即整个传输完成后，它会发送一个空的数据块，即 <code>Content-Length</code> 设置为零的数据块，以告诉客户端传输已完成。为了通知客户关于分块传输，服务器需要包含头<code>Transfer-Encoding: chunked</code></p></li><li><p>不同于 <code>HTTP/1.0</code> 只有基本身份认证， <code>HTTP/1.1</code> 包括摘要和代理认证</p></li><li><p>高速缓存</p></li><li><p>字节范围</p></li><li><p>字符集</p></li><li><p>语言协商</p></li><li><p>客户端Cookie</p></li><li><p>增强的压缩支持</p></li><li><p>新的状态码</p></li><li><p>和更多</p></li></ul><p>如果要完整的讲述 <code>HTTP/1.1</code>，篇幅会超出想象，如果你打算深入了解，可以阅读 <a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener external nofollow noreferrer">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a>。</p><p><code>HTTP/1.1</code> 于 1999 年推出，早已成为标准。虽然它改进了非常多，但是随着互联网的发展，它已经开始显得年老体衰了。现在加载网页比以前更费资源。一个简单的网页都可能打开 30 多个连接。<code>HTTP/1.1</code> 是持久连接，那为什么还需要这么多连接？因为在任何时刻都只有一个有效连接。 <code>HTTP/1.1</code> 试图通过引入管线化来解决这个问题，但并没有完全解决这个问题，由于阻塞问题，一旦请求被阻塞在管线化中，它将不得不等待下一个请求。为了克服这些缺点 <code>HTTP/1.1</code> ，开发人员开始实施解决方法，例如合并 CSS / Javascript文件，域名分片等。</p><h2 id="SPDY-2009"><a href="#SPDY-2009" class="headerlink" title="SPDY - 2009"></a>SPDY - 2009</h2><p>Google 开始尝试设计一种新协议来减少网页的延迟，使得网页加载更快并提升安全性，2009 年， SPDY 面世。</p><blockquote><p><code>SPDY</code> 是 Google 的商标，并不是缩写。</p></blockquote><p>他们意识到，如果继续增加带宽来提升网络性能，必定会到底一个临界点之后无法继续提升。而在有延迟的情况下，不断降低延迟，那么性能将会是一个常数。这是 SPDY 性能提升背后的核心理概念，减少延迟来提升网络性能。</p><blockquote><p>对于那些不懂概念的人， 延迟即数据从源传输到目标的耗时，带宽就是每秒传输的数据量.</p></blockquote><p><code>SPDY</code> 的特点包括，复用，压缩，优先级，安全等。</p><p><code>SPDY</code> 并没有真正尝试取代 HTTP，它是通过 HTTP 存在于应用层的转换层，并在将请求发送到线路之前修改了请求。它开始成为事实上的标准，大多数浏览器开始实施它。</p><p>2015年，Google 不希望有两个相互竞争标准，所以他们决定将它合并到 HTTP 中，同时推进 <code>HTTP/2</code> 和弃用 SPDY。</p><h2 id="HTTP-2-2015"><a href="#HTTP-2-2015" class="headerlink" title="HTTP/2 - 2015"></a>HTTP/2 - 2015</h2><p>到现在，你应该知道了为什么需要对 HTTP 协议进行改进。 <code>HTTP/2</code> 专为低延迟传输内容而设计。它和 <code>HTTP/1.1</code> 的主要功能或差异有</p><ul><li>使用二进制而不是文本</li><li>复用 - 单个连接中进行多个异步 HTTP 请求</li><li>HPACK 头部压缩</li><li>服务器推送 - 单请求多响应</li><li>请求优先级</li><li>安全</li></ul><p><img src="/img/http2/http-http2-2.svg" alt=""></p><h3 id="1-二进制协议"><a href="#1-二进制协议" class="headerlink" title="1. 二进制协议"></a>1. 二进制协议</h3><p><code>HTTP/2</code> 通过使二进制协议来减少存在于 <code>HTTP/1.x</code> 中的延迟问题。二进制协议更容易解析，但对于人来说，几乎没有可读性。<code>HTTP/2</code> 主要构件是帧和流</p><h4 id="帧和流"><a href="#帧和流" class="headerlink" title="帧和流"></a>帧和流</h4><p>HTTP 会话由一个或多个帧组成。<code>HEADERS</code> 帧用于存放元数据，数据则是存放在 <code>DATA</code> 帧中，还有其他几种类型的帧（HEADERS，DATA，RST_STREAM，SETTINGS，PRIORITY 等），您可以通过<a href="https://http2.github.io/http2-spec/#FrameTypes" target="_blank" rel="noopener external nofollow noreferrer"><code>HTTP/2</code> 规范</a>进行检查。</p><p>每个 <code>HTTP/2</code> 请求和响应都被赋予一个唯一的流 ID，并将其分为多个帧。帧只不过是二进制数据，一组帧被称为一个流。每个帧都有一个流标识，标识它所属的流，每个帧都有一个公共头。此外，除了唯一的流 ID 之外，有趣的是，客户端/服务器发起的请求或响应是奇数/偶数的流 ID。</p><p>除 <code>HEADERS</code> 和 <code>DATA</code>之外，我认为另一种值得一提的帧类型是 <code>RST_STREAM</code>，它是一种特殊的帧类型，用于中止流，即客户端可以发送此帧让服务器知道我不需要此流了。在 <code>HTTP/1.1</code> 中，使服务器停止向客户端发送响应的唯一方法是关闭连接。在 <code>HTTP/2</code> 中，客户端可以使用 <code>RST_STREAM</code> 并停止接收特定的数据流，同时连接仍然处于打开状态，其他数据流不受影响。</p><h3 id="2-多路复用"><a href="#2-多路复用" class="headerlink" title="2. 多路复用"></a>2. 多路复用</h3><p>由于 <code>HTTP/2</code> 是一个二进制协议，正如我上面所说的那样，它使用帧和流来请求和响应，一旦 TCP 连接打开，所有流将通过相同的连接进行异步发送，而不会需要额外的连接。 然后，服务器以相同的异步方式响应，即响应没有顺序，并且客户端使用分配的流 ID 来标识特定分组所属的流。这也解决了 HTTP/1.x 中存在的 <strong>头部阻塞</strong> 问题，即客户端不必花费时间等待请求，并且其他请求会得到处理。</p><h3 id="3-HPACK-头部压缩"><a href="#3-HPACK-头部压缩" class="headerlink" title="3. HPACK 头部压缩"></a>3. HPACK 头部压缩</h3><p>它是专门为头部压缩设计的一套压缩算法。其实质是，当我们不断地从同一个客户端访问服务器时，我们可能会发送很多相同的数据，有时可能会有 cookies，增加了头的大小，从而导致占用了带宽、增加了延迟。为了克服这个问题，<code>HTTP/2</code> 引入了头压缩。</p><p><img src="/img/http2/http-http2-3.png" alt=""></p><p>与请求和响应不同，头文件不是使用 <code>gzip</code> 或 <code>compress</code> 等压缩的，头压缩的机制不同，它使用 Huffman code 对文本值进行编码，并且头文件表由客户端和服务器共同维护，并且客户端和服务器都会在后续请求中省略任何重复标题（例如 user-agent），使用由两者维护的头文件表来引用。</p><p><code>HTTP/2</code> 的头文件仍和 HTTP/1.1 一样，只是添加一些伪报头字段，例如 <code>:method</code>, <code>:scheme</code></p><h3 id="4-服务器推送"><a href="#4-服务器推送" class="headerlink" title="4. 服务器推送"></a>4. 服务器推送</h3><p>服务器推送是 <code>HTTP/2</code> 的另一个重要特性，如果服务器知道客户端将要请求某个资源，可以将其推送到客户端，不需要客户端询问它。 一个网站中的网页，里面有一个名为 styles.css 的样式表定义各种样式。当用户向务器请求这个网页时，可以向用户推送 styles.css，同时发送这个网页。</p><p>服务器推送允许服务器通过推送它知道客户端需要的数据来减少往返次数。 它是如何完成的呢？服务器发送一个名为 <code>PUSH_PROMISE</code> 的特殊帧，通知客户端：“嗨，我将把这个资源发送给你！不要问我。” <code>PUSH_PROMISE</code> 帧与导致推送发生的流相关联，并且它包含承诺的流 ID，即服务器将发送要推送的资源的流。</p><h3 id="5-请求优先级"><a href="#5-请求优先级" class="headerlink" title="5. 请求优先级"></a>5. 请求优先级</h3><p>客户端可以通过将优先级信息添加到在打开流的 <code>HEADERS</code> 帧中来为流分配优先级。在任何时候，客户端都可以发送 <code>PRIORITY</code> 帧来改变流的优先级。</p><p>如果没有任何优先级信息，服务器会异步处理请求，即没有任何顺序。 如果分配给流的优先级，则基于该优先级信息，由服务器决定需要给予多少资源来处理请求。</p><h3 id="6-安全"><a href="#6-安全" class="headerlink" title="6. 安全"></a>6. 安全</h3><p>关于是否应该对 <code>HTTP/2</code> 进行强制使用安全连接（通过<code>TLS</code>）的讨论，最后，还是决定不强制执行。 但是，大多数游览器表示，将只支持基于 <code>TLS</code> 的 <code>HTTP/2</code>。所以，虽然 <code>HTTP/2</code> 不需要加密，但是游览器是大佬。而且，通过 <code>TLS</code> 实现 <code>HTTP/2</code> 强加了一些要求。例如，必须使用 <code>TLS 1.2</code> 及更高版本，必须有最低限制的最小密钥长度，需要临时密钥等。</p></article><p class="post-footer-info mb-0 pt-0">本文发表于&nbsp;<time datetime="2017-04-04T21:05:01.000Z" itemprop="datePublished">2017-04-05</time> , 最后修改于&nbsp;<time datetime="2021-06-11T08:02:37.187Z" itemprop="dateModified">2021-06-11</time></p><p class="post-footer-info mb-0 pt-2"></p></div><div class="post-nav px-2 bg-gray"><ul class="pagination"><li class="page-item page-prev"><a href="/2017/about-personal-blog.html" rel="prev"><div class="page-item-title"><i class="icon icon-back" aria-hidden="true"></i></div><div class="page-item-subtitle">关于个人博客</div></a></li><li class="page-item page-next"><a href="/2017/owasp-2.html" rel="next"><div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div><div class="page-item-subtitle">OWASP Top 10 - Authentication and Password Management</div></a></li></ul></div></div></div></div></div><footer class="text-center"><p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span> <a class="footer-copyright-a" href="https://01.946771200.xyz">Aoang's Blog</a></p><p class="footer-text mb-0"></p></footer><script>window.lazyLoadOptions={elements_selector:".lazyload",threshold:50},document.getElementById("copyright-year").textContent=(new Date).getFullYear()</script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@latest" async></script><script async>window.onload=function(){var e=document.createElement("script"),t=document.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.src="/sw-register.js?v="+Date.now(),t.parentNode.insertBefore(e,t)}</script></body></html>