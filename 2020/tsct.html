<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="//946771200.xyz"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="dns-prefetch" href="//www.googletagmanager.com"><link rel="dns-prefetch" href="//www.google-analytics.com"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,maximum-scale=5,viewport-fit=cover"><meta name="renderer" content="webkit"><title>QQ 安全中心动态密钥 | Aoang&#39;s Blog</title><link rel="icon" type="image&#x2F;ico" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/apple-touch-icon.png"><link rel="icon" typt="image&#x2F;png" sizes="192x192" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/android-chrome-192x192.png"><link rel="icon" typt="image&#x2F;png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/favicon-32x32.png"><link rel="icon" typt="image&#x2F;png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/favicon-16x16.png"><link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/safari-pinned-tab.svg" color=""><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/spectre.css@latest"><style>body{background-color:#f8f9fa}a,a:visited{color:#0070ff}a:active,a:focus,a:hover{color:#0070ff;opacity:.75}#post-content a,#post-content a:focus,#post-content a:hover,#post-content a:visited{color:#005eb9;opacity:1}.post-entry .card-body a{color:#0070ff}.avatar{background:#444}.navbar-link,.navbar-link:visited,.timeline .timeline-item .timeline-icon.icon-lg{color:#0070ff}.navbar-link:hover{color:#0070ff;opacity:.8}#disqus-loadmore-button,#disqus-switch-to-direct,#disqus_click_btn,#search-input .btn{background:#727e96;border-color:#727e96;color:#fff}#post-toc a.post-toc-link,#post-toc a.post-toc-link:visited,.share-menu.menu .menu-item>a{color:#727e96}.share-menu.menu .menu-item>a:focus,.share-menu.menu .menu-item>a:hover,.share-menu.menu .menu-item>a:visited{color:#50596c;background:#f8f9fa;opacity:.85}</style><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/css/highlight/github.min.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="/css/highlight/github.min.css"></noscript><script>!function(n){"use strict";n.loadCSS||(n.loadCSS=function(){});var o=loadCSS.relpreload={};if(o.support=function(){var e;try{e=n.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),o.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},o.poly=function(){if(!o.support())for(var t=n.document.getElementsByTagName("link"),e=0;e<t.length;e++){var a=t[e];"preload"!==a.rel||"style"!==a.getAttribute("as")||a.getAttribute("data-loadcss")||(a.setAttribute("data-loadcss",!0),o.bindMediaToggle(a))}},!o.support()){o.poly();var t=n.setInterval(o.poly,500);n.addEventListener?n.addEventListener("load",function(){o.poly(),n.clearInterval(t)}):n.attachEvent&&n.attachEvent("onload",function(){o.poly(),n.clearInterval(t)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:n.loadCSS=loadCSS}("undefined"!=typeof global?global:this)</script><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="Aoang's Blog"><meta name="msapplication-starturl" content="https://01.946771200.xyz"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Aoang's Blog"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link rel="manifest" href="/manifest.json"><link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="Aoang's Blog"><meta property="og:title" content="QQ 安全中心动态密钥 | Aoang&#39;s Blog"><meta property="og:site_name" content="Aoang&#39;s Blog"><meta property="og:type" content="article"><meta property="og:url" content="https:&#x2F;&#x2F;01.946771200.xyz&#x2F;2020&#x2F;tsct.html"><meta property="og:locale" content="zh-CN"><meta name="description" content="不得不说，有现成的技术方案不用，非要跑去魔改一个，这真是国内众多大厂的特征之一，QQ 安全中心的动态密钥就是如此。 现有的 One Time Password 方案大多分为 HOTP 和 OTOP，前者基于事件，后者基于时间。在两步验证的安全策略中，大多数都是采用基于时间的 OTOP 算法。OTOP 算法一般来说都是通用的，因为都是遵循 RFC6238 来实现的。而 QQ 安全中心的算法是魔改 R - Aoang - Aoang&#39;s Blog"><meta name="keywords" content="QQ安全中心, Telegram, Serverless, Vercel, Aoang, Aoangc, Blog, 博客, 网络, 安全"><meta property="article:published_time" content="2020-08-30T12:11:07.000Z"><meta property="article:modified_time" content="2020-08-30T12:11:07.000Z"><meta property="og:updated_time" content="2020-08-30T12:11:07.000Z"><meta property="article:author" content="Aoang"><meta property="article:tag" content="QQ安全中心, Telegram, Serverless, Vercel, Aoang, Aoangc, Blog, 博客, 网络, 安全"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://01.946771200.xyz/2020/tsct.html"><meta name="generator" content="Hexo 4.0.0"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-130715850-2"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-130715850-2")</script><script type="application/ld+json">{
    "@context": "http://schema.org",
    "url": "https://01.946771200.xyz/2020/tsct.html",
    "@type": "BlogPosting",
    "logo": "https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/android-chrome-192x192.png",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://01.946771200.xyz/2020/tsct.html"
    },
    "headline": "QQ 安全中心动态密钥 | Aoang&#39;s Blog",
    
    "image": {
        "@type": "ImageObject",
        "url": "https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/android-chrome-192x192.png"
    },
    
    "datePublished": "2020-08-30T12:11:07.000Z",
    "dateModified": "2020-08-30T12:11:07.000Z",
    "author": {
        "@type": "Person",
        "name": "Aoang",
        "image": {
            "@type": "ImageObject",
            "url": "https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/img.png"
        },
        "description": "岁月在电波中流淌，人生在音乐中升华"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Aoang&#39;s Blog",
        "logo": {
            "@type": "ImageObject",
            "url": "https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/favicon/android-chrome-192x192.png"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "https://01.946771200.xyz/search.html?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "QQ安全中心, Telegram, Serverless, Vercel, Aoang, Aoangc, Blog, 博客, 网络, 安全",
    "description": "不得不说，有现成的技术方案不用，非要跑去魔改一个，这真是国内众多大厂的特征之一，QQ 安全中心的动态密钥就是如此。 现有的 One Time Password 方案大多分为 HOTP 和 OTOP，前者基于事件，后者基于时间。在两步验证的安全策略中，大多数都是采用基于时间的 OTOP 算法。OTOP 算法一般来说都是通用的，因为都是遵循 RFC6238 来实现的。而 QQ 安全中心的算法是魔改 R - Aoang - Aoang&#39;s Blog"
}</script><link rel="alternate" href="/atom.xml" title="Aoang's Blog" type="application/atom+xml"></head><body><header><h1 class="header-title text-center"><a href="/">Aoang&#39;s Blog</a></h1><p class="text-center header-slogan">岁月在电波中流淌，人生在音乐中升华</p><nav class="navbar-section text-center"><a href="/" class="navbar-link">首页</a> <a href="/archives/" class="navbar-link">归档</a> <a href="/search.html" class="navbar-link">搜索</a> <a href="/project.html" class="navbar-link">项目</a> <a href="/wiki/" class="navbar-link">文档</a> <a href="/links.html" class="navbar-link">友链</a> <a href="/about.html" class="navbar-link">关于</a></nav></header><div class="post-container"><div id="post-card" class="card"><div class="card-item-container"><div class="card-inner-cell"><div class="card-header"><h1 class="card-title h3 mb-2">QQ 安全中心动态密钥</h1><div class="post-header-info"><p class="post-header-info-left text-gray"><img class="author-thumb lazyload" data-src="https://cdn.jsdelivr.net/gh/Aoang/Aoang.github.io@master/img/img.png" src="/img/suka-lazyload.gif" alt="Aoang's Avatar"> <span>2020-08-30</span></p><div class="post-header-info-right"></div></div></div><div class="card-body"><article id="post-content"><p>不得不说，有现成的技术方案不用，非要跑去魔改一个，这真是国内众多大厂的特征之一，QQ 安全中心的动态密钥就是如此。</p><p>现有的 One Time Password 方案大多分为 HOTP 和 OTOP，前者基于事件，后者基于时间。<br>在两步验证的安全策略中，大多数都是采用基于时间的 OTOP 算法。OTOP 算法一般来说都是通用的，因为都是遵循 <a href="https://tools.ietf.org/html/rfc6238" target="_blank" rel="noopener external nofollow noreferrer">RFC6238</a> 来实现的。<br>而 QQ 安全中心的算法是魔改 <a href="https://tools.ietf.org/html/rfc6238" target="_blank" rel="noopener external nofollow noreferrer">RFC6238</a> 实现的，导致除了它自己的客户端，其他的 OTOP 客户端都没办法用。</p><p>这里就不得不吐槽了，QQ 安全中心已经被砍成残废了，但是不知道为什么，还是有部分服务是依赖它的。<br>比如，某龙的微信全面抛弃了这种带有 QQ 字眼的安全中心，但是他的邮箱还严重依赖 QQ 安全中心。</p><p>平时基本上不怎么用，万年都不开一次，有时候还会风控你，过于依赖手机，只能想办法迁移到其他平台，比如 Bitwarden。<br>可惜这种丧心病狂的魔改版，没有什么其他软件会兼容，当然腾讯手机管家这种要吞掉 QQ 安全中心的除外。</p><p>不过幸运的是找 Github 上找到了 <a href="https://github.com/HyperSine" target="_blank" rel="noopener external nofollow noreferrer">HyperSine</a> 的 <a href="https://github.com/HyperSine/forensic-qqtoken" target="_blank" rel="noopener external nofollow noreferrer">forensic-qqtoken</a> ，里面描述了算法的思路、公式及其解密方法。</p><p>能解密就好说了，谁骚操作不是一大堆。</p><p>很麻利的从手机把相关文件拖到电脑上了，然后跑 Python 脚本。<br>嗯？怎么第一步就报错了，啥情况？哦，是 WSL 里的 Python 没 cryptography，给它装上。继续跟着教程傻瓜式的走哇，等会等会，WSL 没装 sqlite3…看着 <code>zsh: command not found: sqlite3</code> 不知道是该感叹自己手太快了还是脑袋太飘了。</p><p>提取出密钥，验证一下生成的验证码是不是和 QQ 安全中心一致，好像完事了？</p><p>嗯？我是谁？我在哪儿？我不可能每次用都给它跑一遍吧？这在手机上的话，难不成还先 SSH 到服务器上跑个验证码下来再填？</p><p>不行不行，这个轮子它又方又…太方了，得想个办法整成六边形的。</p><p>要不，咱写个 API 然后起个服务器跑？好像有点浪费哈，先不说这东西平时根本用不上，API 服务做的方便就不安全，做的安全又不方便，很难两全其美，这个不行不行，这最多就是五边形。</p><p>或许可以通过 Telegram Bot 来交互？这样似乎可行？但是单独起个服务还是不太爽的样子，这勉勉强强算是六边形了。</p><p>不想这种东西占用自己的服务器资源的话，该怎么做呢？陷入沉思…</p><p>要不，用 GitHub Action 定时把一段时间的验证码全部跑出来，然后把功能集成到自己的 Bot 里，让它直接去读 GitHub 仓库的内容？怎么好像越来越复杂了…这肯定是个三角形！</p><p>Vercel 不是有免费的 Serverless 可以用吗？</p><p>利用 Telegram Webhook 的机制，有消息传入的时候 Telegram 调起 Serverless，生成验证码后发送给用户。</p><p>这个思路好像不错，要不，实现一个？这应该算是个椭圆形了吧，推它一把它能自己滚一圈儿，符合椭圆形的标准。</p><p>出于对 Python 的「喜爱」，我决定使用 Go 来写。<br>首先，根据 <a href="https://github.com/HyperSine/forensic-qqtoken/blob/master/generate-qqtoken.py#L30-L61" target="_blank" rel="noopener external nofollow noreferrer">HyperSine 写的生成函数</a> 重写了一个 Go 版本的。</p><p>在用非常规标准（用 main 函数跑测试，跑完了就把测试代码删了的人还有没有？）完成了函数的单元测试之后，开始考虑下一步该怎么做。</p><p>平时使用 OTOP 的时候，大部分服务是有容差的。</p><p>啥是容差？一看就知道你没看上面发的 RFC6238，这里不发了，自己搜去。</p><p>OTOP 默认是 30 秒一刷新，很多服务都允许你有时间误差，具体没测试过。<br>实现机制可能就是简单的计算了一下当前时间的验证码、已经失效的一个验证码，然后拿着你输入的进行对比。</p><p>因为不清楚 QQ安全中心是否有容差机制，再加上是使用 Telegram 而不是专业的密码管理器，很大概率是需要手动复制的，所以就多生成几个。<br>这样可以避免因为网络问题，验证码一再过期这种情况。</p><p>那么就根据当前时间计算出当前的验证码，然后再计算出当前验证码的前一个和后一个，在 Telegram 上以这种样式来展示 <del>593111</del> | <code>243735</code> | <code>166949</code> 刚刚好。<br>当前验证码和未来的验证码可能是需要复制的，所以使用等宽，这样在 Telegram 上点击即可复制。<br>已经失效的验证码使用删除线显示，毕竟只是需要看看，没有其他的特殊需求了。</p><p>接下来需要测试一下 Webhook，毕竟之前没有做过这种用 Serverless 来实现 Telegram Bot 的骚操作，稳一点比较好。</p><p>先使用默认的轮询获取了几次 Telegram 发给自己的数据。然后将代码调整为 Webhook 模式，监听本地 <code>127.0.0.1</code>，用 Postman 给程序发送之前 Telegram 给我发过的消息。</p><p>嗯，测试完成。</p><p>这里有个题外话，Telegram 设置 Webhook 的 URL 应当是不被暴露的，因为 Telegram 给你发送的消息是没有鉴权机制的。<br>如果有人知道了这个服务的 Webhook URL，然后拿到了账户的 Telegram ID，就可以通过不断的给 Webhook URL 发送消息完成来骚扰。</p><p>这个问题有没有办法解决呢，办法是有的，检查来源 IP 是不是 Telegram 的就好了。</p><p>来自 <code>149.154.160.0/20</code> 和 <code>91.108.4.0/22</code> 的 <code>POST</code> 请求就是 Telegram 的服务器，当然还有一些不怎么需要提及的要求，比如必须能处理 TLS1.2+ 的 HTTPS 流量，还需要服务器提供经过验证的非通配符证书，或者是自签名证书。<br>貌似 Vercel 默认给你提供的就是通配符证书，不过我绑定了域名，不受这个影响。</p><p>又想到了一个安全问题，任何账户给这个机器人发消息都能获取到验证码可不行呢，但是我 Telegram 账户有点多，这个问题怎么整？</p><p>将自己的 Telegram ID 存为数组，收到消息时，拿到 Telegram ID 后查一遍数组，看看是否存在？然后再发送验证码？</p><p>这种办法只能自己一个人用啊，如果服务共享给其他人呢？<br>用 <code>map[int64]*Data</code> 来实现，Telegram ID 是 <code>int64</code> 的，将 Secret 等数据丢入 <code>Data</code> 结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">	Secret <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]*Data)</span><br><span class="line"></span><br><span class="line">m[<span class="number">123456789</span>] = &amp;Data&#123;&#125;</span><br><span class="line"></span><br><span class="line">myData := &amp;Data&#123;</span><br><span class="line">	Secret: <span class="string">"qwertyuiop"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m[<span class="number">10001</span>] = myData</span><br><span class="line">m[<span class="number">10002</span>] = myData</span><br><span class="line">m[<span class="number">10003</span>] = myData</span><br><span class="line"></span><br><span class="line">m[<span class="number">40001</span>] = &amp;Data&#123;</span><br><span class="line">	Secret: <span class="string">"asdfghjkl"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一对一和多对一就完成了，至于多对多那就算了吧。<br>多对多的实现想要人性化一点，就得折腾 Telegram 那个什么鬼键盘，然后根据键盘里面的回调数据来让程序生成验证码。多对多的那个多有点多的时候，还得考虑键盘的布局翻页。<br>这么复杂，谁这么玩，打死他！</p><p>不过如果有人愿意自己挖坑自己埋，弄出来之后还比较好用的话，请告诉我！</p><hr><p>代码整理了一下，放在 <a href="https://github.com/Aoang/TSCT" target="_blank" rel="noopener external nofollow noreferrer">GitHub</a> 上了，有需要的可以自己拿去改改，也可以直接弄去部署。<br>但是因为安全问题，记得认真看说明，不然小心裤子没了。</p></article><p class="post-footer-info mb-0 pt-0">本文发表于&nbsp;<time datetime="2020-08-30T12:11:07.000Z" itemprop="datePublished">2020-08-30</time></p><p class="post-footer-info mb-0 pt-2"><span class="post-tags-list mt-2"><a class="post-tags-list-item" href="/tags/QQ%E5%AE%89%E5%85%A8%E4%B8%AD%E5%BF%83/" rel="tag">#&nbsp;QQ安全中心</a> <a class="post-tags-list-item" href="/tags/Telegram/" rel="tag">#&nbsp;Telegram</a> <a class="post-tags-list-item" href="/tags/Serverless/" rel="tag">#&nbsp;Serverless</a> <a class="post-tags-list-item" href="/tags/Vercel/" rel="tag">#&nbsp;Vercel</a></span></p></div><div class="post-nav px-2 bg-gray"><ul class="pagination"><li class="page-item page-prev"><a href="/2020/summary-2020.html" rel="prev"><div class="page-item-title"><i class="icon icon-back" aria-hidden="true"></i></div><div class="page-item-subtitle">2020 年总结</div></a></li><li class="page-item page-next"><a href="/2020/search-engine-usage.html" rel="next"><div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div><div class="page-item-subtitle">搜索引擎的使用</div></a></li></ul></div></div></div></div></div><footer class="text-center"><p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span> <a class="footer-copyright-a" href="https://01.946771200.xyz">Aoang's Blog</a></p><p class="footer-text mb-0"></p></footer><script>window.lazyLoadOptions={elements_selector:".lazyload",threshold:50},document.getElementById("copyright-year").textContent=(new Date).getFullYear()</script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@latest" async></script><script async>window.onload=function(){var e=document.createElement("script"),t=document.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.src="/sw-register.js?v="+Date.now(),t.parentNode.insertBefore(e,t)}</script></body></html>